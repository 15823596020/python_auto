"""
使用列表推导式写下面这个算法题
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
•	示例 1：
输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
•	示例 2：
输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]
•	提示：
1 <= A.length <= 10000
-10000 <= A[i] <= 10000
A 已按非递减顺序排序。
"""
# 列表推导式,sorted()表示对列表推导出来的结果进行排序
list_a = [-7, -3, 2, 3, 11, -4, -1, 0, 3, 10, -10000, 10000]
print(sorted([i ** 2 for i in list_a]))

# 用函数改造，列表推导式
# def list_methon(list):
#     print(sorted([i ** 2 for i in list]))
# # 调用函数并传参
# list_a = [-7, -3, 2, 3, 11, -4, -1, 0, 3, 10, -10000, 10000]
# list_methon(list_a)

# 先用for循环实现需求
# 定义一个需要操作的列表
# list_a = [-4, -1, 0, 3, 10]
# list_a = [-7, -3, 2, 3, 11]
# list_a = [-4]
# list_a = [-7, -3, 2, 3, 11, -4, -1, 0, 3, 10, -10000, 10000]
# 定义一个空列表，用于存放每个数字的平方组成的新数组
# list_b = []
# # 遍历需操作的整个列表list_a
# for i in list_a:
#     # print(i)
#     # 将列表中的每个数字求平方，并存入新列表list_b中
#     list_b.append(i ** 2)
#     # # 方法一：对list_b进行升序排序，对新列表进行冒泡排序
#     # # 第m次排序
#     # for m in range(len(list_b) - 1):
#     #     # 每次排序，比较的次数为n次
#     #     for n in range(len(list_b) - 1 - m):
#     #         # 比较相邻两个数的大小
#     #         if list_b[n] > list_b[n + 1]:
#     #
#     #             # 如果前一个数大于后一个数，就交换两个数的位置
#     #             list_b[n], list_b[n + 1] = list_b[n + 1], list_b[n]
#
# # 方法二：对list_b进行升序排序
# list_b.sort()
# # 打印新数组
# print(list_b)

